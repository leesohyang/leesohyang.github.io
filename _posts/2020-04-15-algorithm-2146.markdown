---
layout: post
title:  "[삼성 SW 역량테스트] 2146"
subtitle:   "[삼성 SW 역량테스트] 2146"
categories: algorithm language 
tags: algorithm language C++
comments: true
---


## 문제 
---
다리만들기 문제.

가능한 모든 다리를 만들어놓고(조합 필요없음)
최소스패닝트리 알고리즘 적용하면 된다.
 

## 코드
---



    '''c
	#include <iostream>
	#include<fstream>
	#include <vector>
	#include<iostream>
	#include <algorithm>
	#include <deque>
	#include<queue>
	//#include <bits/stdc++.h> 백준제출용

	using namespace std;
	#define INF 1000
	#define ISLAND_MAX 6 + 1
	#define MAX 10
	int unf[ISLAND_MAX];
	
	int board[MAX][MAX], ch[MAX][MAX];
	int N, M, ans;
	int dir[4][2] = { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };
	
	vector<pair<int, int> > Area_Pos[7];
	int name = 1;
	
	struct Bridge {
	    int start, end, distance;
	    Bridge(int x, int y, int z) {
	        start = x;
	        end = y;
	        distance = z;
	    }
	    bool operator<(const Bridge& bb)const {
	
	        return distance < bb.distance; //오름차순은 최소힙의 반대군요
	    }
	};
	
	int Find(int x)
	{
	    if (unf[x] == x) return x;
	    else return unf[x] = Find(unf[x]); //이러면 될걸
	}
	
	void Union(int x, int y)
	{
	    int xx = Find(x); //xx, yy = 부모
	    int yy = Find(y);
	
	    if (xx != yy) unf[xx] = yy; // 부모가 다르면-> 부모 체인지 
	
	}
	int getDistanceBetweenTwoPoints(int number, int fixed, int x1, int y1) { //점끼리의 거리 
	    if (y1 > x1) {
	        int temp = y1; y1 = x1; x1 = temp;
	    }
	
	    for (int i = y1 + 1; i < x1; i++) {
	        if (number == 0 && board[fixed][i] != 0) return INF;  //점과 점 사이에 바다가 아니라 섬이 있는 경우. 
	        else if (number == 1 && board[i][fixed] != 0) return INF;
	    }
	
	    return x1 - y1 - 1;
	}
	
	int getDistance(vector<pair<int, int> >  v1, vector<pair<int, int> > v2) { // 섬끼리의 거리 
	    int res = INF;
	    for (int i = 0; i < v1.size(); i++) {
	        for (int j = 0; j < v2.size(); j++) {
	            if (v1[i].first == v2[j].first) {
	                int dis = getDistanceBetweenTwoPoints(0, v1[i].first, v1[i].second, v2[j].second); //row는 같고 col이 다름
	                if (dis > 1) res = min(res, dis);
	            }
	            if (v1[i].second == v2[j].second) {
	                int dis = getDistanceBetweenTwoPoints(1, v1[i].second, v1[i].first, v2[j].first); // col이 같고 row가 다름
	                if (dis > 1) res = min(res, dis);
	            }
	        }
	    }
	    if (res != INF) return res;
	    else return INF;
	}
	
	
	int main(void)
	{
	    ios_base::sync_with_stdio(false);
	    ifstream cin;
	
	
	    cin.open("input.txt");
	    cin >> N >> M;
	    for (int i = 0; i < N; i++) {
	        for (int j = 0; j < M; j++) {
	            cin >> board[i][j];
	            if (board[i][j]) board[i][j] = -1; //1이면 -1로 바꿔줌
	        }
	    }
	
	    for (int i = 0; i < N; i++) {
	        for (int j = 0; j < M; j++) {
	            if (board[i][j] == -1) {
	                queue<pair<int, int> > Q;
	                Q.push({ i, j });
	                ch[i][j] = 1;
	                board[i][j] = name;
	                Area_Pos[name].push_back({ i, j });
	                while (!Q.empty()) {
	                    pair<int, int> tmp = Q.front();
	                    Q.pop();
	                    for (int k = 0; k < 4; k++) {
	                        int xx = tmp.first + dir[k][0];
	                        int yy = tmp.second + dir[k][1];
	                        if (xx >= 0 && yy >= 0 && xx < N && yy < M && board[xx][yy] == -1 && ch[xx][yy] == 0) {
	                            Q.push({ xx, yy });
	                            ch[xx][yy] = 1;
	                            board[xx][yy] = name;
	                            Area_Pos[name].push_back({ xx, yy });
	                        }
	                    }
	                }
	                name++;
	            }
	        }
	    }//naming완료 지금 섬이 5개면 name값은 6임. 
	
	    vector<Bridge> Node;
	
	    for (int i = 1; i < name; i++) {   //만들수있는 다리 무조건 다놓기
	        for (int j = i + 1; j < name; j++) {
	
	
	            int dist = getDistance(Area_Pos[i], Area_Pos[j]);
	            if (dist != INF) Node.push_back({ i, j, dist });
	
	        }
	    }
	    //위에꺼 한 다음에 union&find 최소스패닝트리
	    sort(Node.begin(), Node.end()); //이게 안되나? 왜 구조체하면 sort안되지 
	
	    for (int i = 1; i < name; i++) unf[i] = i;
	
	    for (int i = 0; i < Node.size(); i++) //간선개수
	    {
	        int Node1 = Node[i].start;
	        int Node2 = Node[i].end;
	        int fa = Find(Node1);
	        int fb = Find(Node2);
	        if (fa != fb)
	        {
	            Union(Node1, Node2);
	            ans = ans + Node[i].distance;
	
	        }
	    }
	    for (int i = 1; i < name; i++) {
	        if (Find(i) != Find(1)) {
	            ans = -1;
	        }
	    }
	    cout << ans;
	
	    return 0;
	}
    '''

